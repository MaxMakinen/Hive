diff --git a/put_tetro.c b/put_tetro.c
old mode 100755
new mode 100644
index 5c09b9d..f9ccc94
--- a/put_tetro.c
+++ b/put_tetro.c
@@ -119,16 +119,14 @@ int	put_tetro(t_tetro *tetro, t_utils utils, size_t g_size)
 	return (-1);
 }
 
-size_t	lst_size(t_tetro *lst)
+int	lst_size(t_tetro *lst)
 {
-	size_t	size;
+	int	size;
 
 	size = 0;
 	while (lst)
 	{
-		if (size > 0)
-			lst->blocks += 4 * size;
-		lst = lst->next;
+	lst = lst->next;
 		size++;
 	}
 	return (size);
@@ -199,117 +197,89 @@ t_tetro	*next_free(t_tetro *head)
 function to delete tetro.
 */
 
-int	del_tetro(t_tetro *tetro, t_utils utils, size_t g_size)
+int	del_tetro(t_tetro *tetro, t_utils utils)
 {
 	int	piece;
+	int	g_size;
+	int	pos;
 
+	g_size = utils.g_size + 1;
 	piece = 4;
 	tetro->placed = 0;
-	while (utils.grid && piece > 0 && piece < 5)
+	pos = tetro->nl[0];
+	while (utils.grid && piece > 0)
 	{
-		if (utils.grid[utils.pos + tetro->queue[piece] + (g_size * (tetro->nl[piece]))] == tetro->letter)
-			utils.grid[utils.pos + tetro->queue[piece] + (g_size * (tetro->nl[piece]))] = '.';
+		if (utils.grid[pos + tetro->queue[piece] + (g_size * (tetro->nl[piece]))] == tetro->letter)
+			utils.grid[pos + tetro->queue[piece] + (g_size * (tetro->nl[piece]))] = '.';
 		piece--;
 	}
+	tetro->nl[0] = 0;
 	return (1);
 }
 
-/*
-function to step back in the list
-*/
-
-t_tetro *step_back(t_tetro *tetro, t_tetro *read)
-{
-	t_tetro	*temp;
-
-	read->placed = 0;
-	temp = tetro;
-	while (temp->next != read)
-		temp = temp->next;
-	return (temp);
-}
-
 /*
 Crazy ideas that will propably not work.
  */
 
 int	iterative_tree(t_tetro *tetro, t_utils utils, t_tetro *read)
 {
+	t_tetro *solution[tetro->blocks];
 	t_tetro *temp;
+	int		list;
+//	size_t	maxlen;
 
-//	read = next_free(tetro);
-//	if (!read)
-//		return (1);
-	tetro->previous = tetro;
-	utils.pos = 0;
-	while (1)
+//	maxlen = (utils.g_size * utils.g_size) + utils.g_size - 3;
+	list = 0;
+	temp = tetro;
+	while (temp && list < tetro->blocks)
 	{
-		if (put_tetro(read, utils, utils.g_size + 1) == 1)
+		solution[list++] = temp;
+		temp = temp->next;
+	}
+	list = 0;
+	//printf("list_len = %d",tetro->blocks);
+	while (list < tetro->blocks)
+	{
+		//printf("list = %d", list);
+		while (utils.grid[utils.pos] != '\0')
 		{
-			printf("bam\n%s\n",utils.grid);
-			temp = read;
-			read->placed = 1;
-			read->nl[0] = utils.pos;
-			printf("	%d\n",read->nl[0]);
-			read = next_free(read->next);
-			if (!read)
+			if (read && put_tetro(read, utils, utils.g_size + 1) == 1)
 			{
+				read->placed = 1;
+				read->nl[0] = utils.pos;
+				solution[list] = read;
 				read = next_free(tetro);
 				if (!read)
 					return (1);
+				list++;
+				utils.pos = 0;
+				//printf("	Placed\nlist = %d\n%s\n", list, utils.grid);
+				break;
 			}
-			read->previous = temp;
-			utils.pos = 0;
-			continue;
+			utils.pos++;
 		}
-		
-		utils.pos++;
+		if (solution[0]->next == NULL)
+			return (0);
 		while (utils.grid[utils.pos] == '\0')
-		{	
-				printf("	Boop\n\n");
-				printf("%d\n",read->shape_id);
-			read = read->previous;
-//			read->previous = read->previous->previous;
-//			read = temp;
-//			read = step_back(tetro, read);
-			if (!read)
-			{
-				read = next_free(tetro);
-				if (!read)
-					return (0);
-			}
-			read->placed = 0;
-			utils.pos = read->nl[0];
-				printf(" - %d\n",read->nl[0]);
-			del_tetro(read, utils, utils.g_size + 1);
-				printf("%s\n",utils.grid);
-			utils.pos = 0;
-			temp = next_free(read->next);
-			if (!temp)
-			{
-				read = read->previous;
-				continue;
-			}
+		{
+			list--;
+			read = solution[list];
+			solution[list] = tetro;
+			del_tetro(read, utils);
 			read = next_free(read->next);
-			temp = tetro;
-			int bit = 1;
-			while (temp)
-			{
-				printf("previous piece %d nl[0] = %d\n", bit, temp->previous->nl[0]);
-				printf("piece %d nl[0] = %d\n", bit++, temp->nl[0]);
-				temp = temp->next;
-			}
+			//printf("Backtrack\nlist = %d\n%s\n",list , utils.grid);
 			if (!read)
-				return (0);
+				continue;
+			utils.pos = 0;
 		}
 	}
-	return (0);
+	return (1);
 }
 
 
 int	recursive_tree(t_tetro *tetro, t_utils utils, t_tetro *read)
 {
-	size_t	pos;
+//	size_t	pos;
 
 	read = next_free(tetro);
 	if (!read)
@@ -320,16 +290,19 @@ int	recursive_tree(t_tetro *tetro, t_utils utils, t_tetro *read)
 		while (put_tetro(read, utils, utils.g_size + 1) == 1)
 		{
 			read->placed = 1;
-			tetro->nl[0] += 1;
-			pos = utils.pos;
+		//	tetro->nl[0] += 1;
+			tetro->nl[0] = utils.pos;
+		//	pos = utils.pos;
 			if (recursive_tree(tetro, utils, read->next) == 1)
 				return (1);
 			else
 			{
 				read->placed = 0;
-				tetro->nl[0] -= 1;
-				utils.pos = pos;
-				del_tetro(read, utils, utils.g_size + 1);
+		//		tetro->nl[0] -= 1;
+		//		utils.pos = pos;
+				printf("Bactrack1\n%s\n", utils.grid);
+				del_tetro(read, utils);
+				printf("Bactrack\n%s\n", utils.grid);
 				utils.pos = 0;
 				read = next_free(read->next);
 				if (!read)
@@ -350,7 +323,8 @@ t_utils	solver(t_tetro *tetro)
 	utils.pos = 0;
 	read = tetro;
 	utils.g_size = 2;
-	tetro_size = lst_size(tetro) * 4;
+	tetro->blocks = lst_size(tetro);
+	tetro_size = tetro->blocks * 4;
 	while (utils.g_size * utils.g_size < tetro_size)
 		utils.g_size++;
 	utils.grid = make_grid(utils.g_size);
@@ -376,6 +350,43 @@ t_utils	solver(t_tetro *tetro)
 	}
 	return (utils);
 }
+
+t_utils	solver_iterative(t_tetro *tetro)
+{
+	t_tetro	*read;
+	t_utils	utils;
+	size_t	tetro_size;
+
+	utils.pos = 0;
+	read = tetro;
+	utils.g_size = 2;
+	tetro->blocks = lst_size(tetro);
+	tetro_size = tetro->blocks * 4;
+	while (utils.g_size * utils.g_size < tetro_size)
+		utils.g_size++;
+	utils.grid = make_grid(utils.g_size);
+	utils.empty = (utils.g_size * utils.g_size) - tetro_size;
+	while (read)
+	{
+		nl_mem(read);
+		read = read->next;
+	}
+//	while (recursive_tree(tetro, utils, tetro) == 0)
+	while (iterative_tree(tetro, utils, tetro) == 0)
+	{
+		read = tetro;
+		while (read)
+		{
+			read->placed = 0;
+			read = read->next;
+		}
+		utils.g_size++;
+		free(utils.grid);
+		utils.grid = make_grid(utils.g_size);
+		utils.empty = (utils.g_size * utils.g_size) - tetro_size;
+	}
+	return (utils);
+}
 /*
 int	main(void)
 {
